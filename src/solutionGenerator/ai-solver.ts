/**
 * AI Solver
 * 
 * Uses Google Gemini AI to generate complete solutions for programming tasks.
 * Also generates test cases and complexity analysis.
 */

import { GoogleGenerativeAI } from '@google/generative-ai';
import { config } from '../config/index.js';
import { logger } from '../utils/logger.js';
import type { Task } from '../taskSelector/types.js';
import type { Solution, TestCase } from './types.js';

const solverLogger = logger.child('AISolver');

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(config.geminiApiKey);

/**
 * Generate a complete solution for the given task
 */
export async function generateSolutionWithAI(task: Task): Promise<Solution> {
    solverLogger.info(`Generating solution for: "${task.title}"`);

    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

    const prompt = `You are an expert programmer. Solve the following programming problem and provide a complete, working solution in TypeScript.

## Problem
Title: ${task.title}
Difficulty: ${task.difficulty}
Tags: ${task.tags.join(', ')}

Description:
${task.description}

${task.examples ? `Examples:\n${task.examples.map((ex, i) => `Example ${i + 1}:\nInput: ${ex.input}\nOutput: ${ex.output}${ex.explanation ? `\nExplanation: ${ex.explanation}` : ''}`).join('\n\n')}` : ''}

${task.constraints ? `Constraints:\n${task.constraints.join('\n')}` : ''}

## Instructions
Provide your response in the following EXACT format (use these exact headers):

### SOLUTION_CODE
\`\`\`typescript
// Your complete, working TypeScript solution here
// Include proper type annotations
// Include JSDoc comments explaining the approach
\`\`\`

### EXPLANATION
[Explain your approach, algorithm used, and key insights]

### TIME_COMPLEXITY
[Time complexity with explanation, e.g., "O(n) - We iterate through the array once"]

### SPACE_COMPLEXITY
[Space complexity with explanation, e.g., "O(1) - We only use a constant amount of extra space"]

### TEST_CASES
\`\`\`typescript
// Vitest test file content
import { describe, it, expect } from 'vitest';
// Import your solution function here
// ... (you can assume the solution is exported from './solution-final')

describe('Solution Tests', () => {
  it('should handle basic case', () => {
    // Test implementation
  });
  
  it('should handle edge case', () => {
    // Edge case test
  });
  
  // Add 3-5 test cases total
});
\`\`\`

Make sure the solution is:
1. Correct and handles all edge cases
2. Optimized for time and space complexity
3. Well-commented and readable
4. Uses idiomatic TypeScript`;

    try {
        const result = await model.generateContent(prompt);
        const response = result.response.text();

        if (!response) {
            throw new Error('Empty response from Gemini AI');
        }

        return parseSolutionResponse(response, task.id);
    } catch (error) {
        solverLogger.error('Failed to generate solution', error);
        throw error;
    }
}

/**
 * Parse the AI response into a Solution object
 */
function parseSolutionResponse(response: string, taskId: string): Solution {
    // Extract solution code
    const codeMatch = response.match(/### SOLUTION_CODE\s*```typescript\s*([\s\S]*?)```/i);
    const code = codeMatch?.[1]?.trim() ?? '';

    // Extract explanation
    const explanationMatch = response.match(/### EXPLANATION\s*([\s\S]*?)(?=### |$)/i);
    const explanation = explanationMatch?.[1]?.trim() ?? 'Solution generated by AI';

    // Extract time complexity
    const timeMatch = response.match(/### TIME_COMPLEXITY\s*([\s\S]*?)(?=### |$)/i);
    const timeComplexity = timeMatch?.[1]?.trim() ?? 'O(n)';

    // Extract space complexity
    const spaceMatch = response.match(/### SPACE_COMPLEXITY\s*([\s\S]*?)(?=### |$)/i);
    const spaceComplexity = spaceMatch?.[1]?.trim() ?? 'O(1)';

    // Extract test code
    const testMatch = response.match(/### TEST_CASES\s*```typescript\s*([\s\S]*?)```/i);
    const testCode = testMatch?.[1]?.trim() ?? generateDefaultTestCode();

    // Parse test cases from test code
    const testCases = parseTestCases(testCode);

    if (!code) {
        throw new Error('Failed to extract solution code from AI response');
    }

    return {
        taskId,
        code,
        explanation,
        timeComplexity,
        spaceComplexity,
        testCases,
        testCode,
    };
}

/**
 * Parse test cases from test code
 */
function parseTestCases(testCode: string): TestCase[] {
    const testCases: TestCase[] = [];

    // Extract it() blocks
    const itRegex = /it\s*\(\s*['"`](.*?)['"`]/g;
    let match;

    while ((match = itRegex.exec(testCode)) !== null) {
        const description = match[1] ?? 'Test case';
        testCases.push({
            description,
            input: 'See test code',
            expectedOutput: 'See test code',
            isEdgeCase: description.toLowerCase().includes('edge'),
        });
    }

    // Ensure at least one test case
    if (testCases.length === 0) {
        testCases.push({
            description: 'Basic test case',
            input: '[]',
            expectedOutput: '[]',
            isEdgeCase: false,
        });
    }

    return testCases;
}

/**
 * Generate default test code if AI doesn't provide one
 */
function generateDefaultTestCode(): string {
    return `import { describe, it, expect } from 'vitest';

describe('Solution Tests', () => {
  it('should work correctly', () => {
    // TODO: Add test implementation
    expect(true).toBe(true);
  });
});
`;
}

export default generateSolutionWithAI;
